# 객체지향개념1
80년대 초 소프트웨어의 위기 - 빠른 변화를 못쫓아감  
해결책으로 객체지향 언어를 도입 (절차적 -> 객체지향)  

코드의 재사용성이 높고 유지보수가 용이, 중복 코드 제거  
객체지향 언어 = 프로그래밍 언어 + 객체지향개념(규칙)

OOP (object-oriented programming)
### 핵심적인 4가지 특성
1. 캡슐화
2. 상속
3. 추상화
4. 다형성

## ch6-2 클래스와 객체
클래스의 정의 : 클래스란 객체를 정의해 놓은 것  
클래스의 용도 : 클래스는 객체를 생성하는데 사용

객체의 정의 : 실제로 존재하는 것. 사물 또는 개념  
객체의 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름  

ex) 제품 설계도 - 제품   

객체 = 속성(변수) + 기능(메서드)  

## ch6-4 객체와 인스턴스  
객체 : 모든 인스턴스를 대표하는 일반적 용어  
인스턴스 : 특정 클래스로부터 생성된 객체  

클래스 --인스턴스화--> 인스턴스(객체)  

Q. 클래스가 왜 필요한가?  
A. 객체를 생성하기 위해  

Q. 객체가 왜 필요한가?  
A. 객체를 사용하기 위해  

Q. 객체를 사용한다는 것은?  
A. 객체가 가진 속성과 기능을 사용하려고 (변수, 메서드) 

## ch6-6 객체의 생성과 사용  
1. 객체의 생성  
    클래스명 변수명;  // 클래스의 객체를 참조하기 위한 참조변수를 선언  
    변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장
   
    Tv t;  
    t = new Tv();  
2. 객체의 사용  

    t.channel = 7;  
    t.channelDown();  
    System.out.println("현재 채널은 " + t.channel + " 입니다.");  


## ch6_8 객체 배열

객체 배열 == 참조변수 배열

참조변수 여러개 묶어서 하나의 배열로 다루는 것

```
Tv[] tvArr = new Tv[3];
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();
```

## ch6_9 클래스의 정의 (1)

클래스 == 데이터 + 함수

클래스
1. 설계도
2. 데이터 + 함수
3. 사용자 정의 타입

<br/>

1. 변수
   - 하나의 데이터를 저장할 수 있는 공간
2. 배열
   - 같은 종류의 여러 데이터를 하나로 저장할 수 있는 공간
3. 구조체
   - 서로 관련된 여러 데이터(종류 관계X)를 하나로 저장할 수 있는 공간
4. 클래스
    - 데이터와 함수의 결합(구조체 + 함수)

## ch6-11 선언위치에 따른 변수의 종류

- 클래스 영역 : 인스턴스 변수(iv), 클래스 변수(cv = static + iv)
- 메서드 영역 : 지역변수(lv)
- 클래스 영역에는 선언문만 가능
<br/>
<br/>
- 객체 = iv를 묶어놓은 것 (프로그래밍 관점)
<br/>
<br/>
- 인스턴스 변수는 객체가 생성될 때 만들어짐
- 클래스 변수는 클래스가 메모리에 올라갈 때 한 번만 만들어짐
- 지역변수는 변수가 선언되면 생성 -> 메서드 종료 시 자동 제거

## ch6-12 클래스 변수와 인스턴스 변수

- 속성 중에 공통적으로 유지되는 것에 static 을 붙인다.
- cv는 클래스이름.변수 형식으로 사용하는게 좋다.

## ch6-14 메서드란?
- 문장들을 묶어놓은 것
- 작업단위로 문장들의 묶어서 이름 붙인 것
- 값(입력)을 받아서 처리하고, 결과를 반환(출력)
- 메서드의 장점
  - 코드의 중복을 줄일 수 있다.
  - 코드의 관리가 쉽다.
  - 코드를 재사용할 수 있다.
  - 코드가 간결해서 이해하기 쉬워진다.
- 메서드의 작성
  - 반복적으로 수행되는 여러 문장을 메서드로 작성
  - 하나의 메서드는 한 가지 기능만 수행하도록 작성
- 메서드 = 선언부 + 구현부
  - 반환타입 메서드이름 (타입 변수명, 타입 변수명, ...)
  - 구현부

## ch6-20 return문
실행 중인 메서드를 종료하고 호출한 곳으로 되돌아간다.


## ch6-22 호출 스택(call stack)
- 메서드 수행에 필요한 메모리가 제공되는 공간
- 메서드가 호출되면 호출스택에 메모리 할당, 종료되면 해제
- 아래 있는 메서드가 위의 메서드를 호출한 것
- 맨 위의 메서드 하나만 실행 중, 나머지는 대기중

## ch6-23 기본형 매개변수
- 기본형 매개변수
  - 변수의 값을 읽기만 할 수 있다. (read only)
- 참조형 매개변수
  - 변수의 값을 읽고 변경할 수 있다. (read & write)

## ch6-26 static 메서드와 인스턴스 메서드
- 인스턴스 메서드
  - 인스턴스 생성 후, '참조변수.메서드이름()' 으로 호출
  - 인스턴스 멤버(iv, im)와 관련된 작업을 하는 메서드
  - 메서드 내에서 인스턴스 변수(iv) 사용가능
- static 메서드 (클래스메서드)
  - 객체생성없이 '클래스이름.메서드이름()'으로 호출
  - 인스턴스 멤버(iv, im)와 관련없는 작업을 하는 메서드
  - 메서드 내에서 인스턴스 변수(iv) 사용불가
  - ex) Math.random()  객체생성 없이 사용
- iv를 사용 여부로 갈린다.

## ch6-28 static을 언제 붙여야 할까?
- 속성(멤버 변수) 중에서 공통 속성에 static을 붙인다.
- 인스턴스 멤버(iv, im)을 사용하지 않는 메서드에 static을 붙인다.

## ch6-29 메서드 간의 호출과 참조
Q. static 메서드는 static 메서드 호출가능?  
A. O  
Q. staitc 메서드는 인스턴스 변수 사용가능?  
A. X  
Q. static 메서드는 인스턴스 메서드 호출가능?  
A. X  
Q. 왜? staitc 메서드는 인스턴스 멤버를 쓸 수 없나?  
A. static 메서드 호출시 객체 iv묶음이 없을 수도 있어서  

## ch6-30 오버로딩 (overloading)  
한 클래스 안에 같은 이름의 메서드 여러 개 정의하는 것  
오버로딩이 성립하기 위한 조건 3가지  
- 메서드 이름이 같아야 한다.
- 매개변수의 개수 또는 타입이 같아야 한다.
- 반환 타입은 영향없다.

## ch6-32 생성자 (constructor)
- 인스턴스가 생성될 때마다 호출되는 *'인스턴스 초기화 메서드'*
- 객체(iv묶음) iv 초기화. iv 초기화를 편리하게 하려고.
- 생성자 오버로딩 가능
- 규칙
  - 이름이 클래스 이름과 같아야 한다.
  - 리턴값이 없다. (void 안붙임)
  - 모든 클래스는 반드시 생성자를 가져야 한다.

## ch6-33 기본 생성자 (default constructor)
- 매개변수가 없는 생성자
- 생성자가 하나도 없을 때만, 컴파일러가 자동 추가 

## ch6-36 생성자 this()
- 생성자에서 다른 생성자를 호출할 때 사용
- 다른 생성자 호출시 첫 줄에서만 사용가능 


## ch6-37 참조변수 this
- 인스턴스 자신을 가리키는 참조변수
- 인스턴스 메서드(생성자 포함)에서 사용가능
- 지역변수(lv)와 인스턴스 변수(iv)를 구별할 때 사용
- 같은 클래스면 생략 가능하나, 매개변수가 lv하고 이름이 같으면 this로 구별해야 함
- 정리
  - this
    - 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.
    - 모든 인스턴스 메서드에 지연변수로 숨겨진 채로 존재한다.
    - 클래스 메서드는 this 사용 불가
  - this(), this(매개변수)
    - 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용
  - this와 this()는 완전히 다른 것이다.

## ch6-38 변수의 초기화
- 지역변수(lv)는 수동 초기화 해야함 (사용전 꼭!!)

## ch6-39 멤버변수의 초기화
- 멤버변수(iv, cv)
1. 명시적 초기화 (=)
   ```
    class Car {
        int door = 4; // 기본형 (primitive type) 변수의 초기화
        Engine e = new Engine();  // 참조형 (reference type) 변수의 초기화
    }  
    ```
   참조형 변수는 null or 객체주소
2. 초기화 블럭 - {}, static {}
   - 인스턴스 초기화 블럭 : {}
   - 클래스 초기화 블럭 : static {}
   - static {} 예시
   ```
    class StaticBlockTest{
        static int[] arr = new int[10]; // 명시적 초기화
        static { // 클래스 초기화 블럭 - 배열 arr을 난수로 채운다.
            for(int i=0; i<arr.length; i++) {
                arr[i] = (int)(Math.random()*10)+1;
            }
        }
    }
    ```
3. 생성자 (iv초기화)
    ```
   Car(String color, String gearType, int door) { //매개변수 있는 생성자
        this.color = color;
        this.gearType = gearType;
        this door = door;
   ```

- 초기화 3가지
  - 자동초기화
    - 처음에 0으로 초기화
  - 간단초기화
    - = 사용
  - 복잡초기화
    - iv 일 때 {}
    - cv 일 때 static {}
- 클래스 변수 초기화 시점 : 클래스가 처음 초딩될 때 단 한번
- 인스턴스 변수 초기화 시점 : 인스턴스가 생성될 때 마다
- 초기화 순서
  - cv -> iv
  - 자동(0) -> 간단(=) -> 복잡({})

